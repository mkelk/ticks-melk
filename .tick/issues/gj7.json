{
  "id": "gj7",
  "title": "Implement Durable Object for project state sync",
  "description": "Create DO class for real-time tick state synchronization.\n\n## DO Class: ProjectRoom\n\n```typescript\n// src/project-room.ts\nimport { DurableObject } from \"cloudflare:workers\"\n\ninterface Tick {\n  id: string\n  // ... full tick structure\n  updatedAt: string  // ISO timestamp\n}\n\ninterface Connection {\n  id: string\n  socket: WebSocket\n  type: 'local' | 'cloud'  // local = tk run, cloud = browser\n}\n\nexport class ProjectRoom extends DurableObject {\n  ticks: Map\u003cstring, Tick\u003e = new Map()\n  connections: Map\u003cstring, Connection\u003e = new Map()\n\n  async fetch(request: Request): Promise\u003cResponse\u003e {\n    const url = new URL(request.url)\n    \n    if (request.headers.get(\"Upgrade\") === \"websocket\") {\n      return this.handleWebSocket(request)\n    }\n    \n    // REST endpoints for debugging\n    if (url.pathname === \"/state\") {\n      return Response.json(Object.fromEntries(this.ticks))\n    }\n    \n    return new Response(\"Not found\", { status: 404 })\n  }\n\n  async handleWebSocket(request: Request): Promise\u003cResponse\u003e {\n    const { 0: client, 1: server } = new WebSocketPair()\n    \n    const connId = crypto.randomUUID()\n    const connType = new URL(request.url).searchParams.get(\"type\") || \"cloud\"\n    \n    this.connections.set(connId, { id: connId, socket: server, type: connType })\n    \n    server.accept()\n    \n    // Send current state to new connection\n    server.send(JSON.stringify({\n      type: \"state_full\",\n      ticks: Object.fromEntries(this.ticks)\n    }))\n    \n    server.addEventListener(\"message\", (event) =\u003e {\n      this.handleMessage(connId, JSON.parse(event.data))\n    })\n    \n    server.addEventListener(\"close\", () =\u003e {\n      this.connections.delete(connId)\n    })\n    \n    return new Response(null, { status: 101, webSocket: client })\n  }\n\n  handleMessage(sourceId: string, msg: any) {\n    switch (msg.type) {\n      case \"sync_full\":\n        this.handleFullSync(sourceId, msg.ticks)\n        break\n      case \"tick_update\":\n      case \"tick_create\":\n        this.handleTickUpdate(sourceId, msg.tick)\n        break\n      case \"tick_delete\":\n        this.handleTickDelete(sourceId, msg.id)\n        break\n    }\n  }\n\n  handleTickUpdate(sourceId: string, tick: Tick) {\n    const existing = this.ticks.get(tick.id)\n    \n    // Last-write-wins\n    if (!existing || new Date(tick.updatedAt) \u003e new Date(existing.updatedAt)) {\n      this.ticks.set(tick.id, tick)\n      this.broadcast({\n        type: \"tick_updated\",\n        tick\n      }, sourceId)\n    }\n  }\n\n  handleTickDelete(sourceId: string, id: string) {\n    this.ticks.delete(id)\n    this.broadcast({ type: \"tick_deleted\", id }, sourceId)\n  }\n\n  handleFullSync(sourceId: string, ticks: Record\u003cstring, Tick\u003e) {\n    // Merge: newer wins\n    for (const [id, tick] of Object.entries(ticks)) {\n      const existing = this.ticks.get(id)\n      if (!existing || new Date(tick.updatedAt) \u003e new Date(existing.updatedAt)) {\n        this.ticks.set(id, tick)\n      }\n    }\n    \n    // Send merged state back to source\n    const conn = this.connections.get(sourceId)\n    if (conn) {\n      conn.socket.send(JSON.stringify({\n        type: \"state_full\",\n        ticks: Object.fromEntries(this.ticks)\n      }))\n    }\n  }\n\n  broadcast(msg: any, excludeId?: string) {\n    const data = JSON.stringify(msg)\n    for (const [id, conn] of this.connections) {\n      if (id !== excludeId) {\n        conn.socket.send(data)\n      }\n    }\n  }\n}\n```\n\n## Worker Routing\n\n```typescript\n// src/index.ts\nexport default {\n  async fetch(request: Request, env: Env): Promise\u003cResponse\u003e {\n    const url = new URL(request.url)\n    \n    // /api/projects/:project/sync â†’ DO\n    const match = url.pathname.match(/^\\/api\\/projects\\/([^\\/]+)\\/sync/)\n    if (match) {\n      const projectId = match[1]\n      const doId = env.PROJECT_ROOMS.idFromName(projectId)\n      const stub = env.PROJECT_ROOMS.get(doId)\n      return stub.fetch(request)\n    }\n    \n    // ... other routes\n  }\n}\n\nexport { ProjectRoom }\n```\n\n## wrangler.toml\n\n```toml\n[[durable_objects.bindings]]\nname = \"PROJECT_ROOMS\"\nclass_name = \"ProjectRoom\"\n\n[[migrations]]\ntag = \"v1\"\nnew_classes = [\"ProjectRoom\"]\n```",
  "status": "closed",
  "priority": 1,
  "type": "task",
  "owner": "peter@engelbrecht.dk",
  "parent": "y1i",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-21T16:30:50.112248Z",
  "updated_at": "2026-01-21T17:11:39.941124Z",
  "closed_at": "2026-01-21T17:11:39.941124Z",
  "closed_reason": "Implemented ProjectRoom Durable Object for real-time tick sync. Features: WebSocket connections from local/cloud, last-write-wins conflict resolution, state persistence, hibernation support, debug endpoints for state/connections."
}