{
  "id": "o28",
  "title": "Implement reconnection and error handling for DO sync",
  "description": "Handle disconnections, errors, and edge cases in DO sync.\n\n## Connection States\n\n```go\ntype SyncState int\n\nconst (\n    SyncDisconnected SyncState = iota\n    SyncConnecting\n    SyncConnected\n    SyncError\n)\n```\n\n## Reconnection Logic\n\n```go\nfunc (c *Client) Run(ctx context.Context) error {\n    backoff := time.Second\n    maxBackoff := 30 * time.Second\n    \n    for {\n        select {\n        case \u003c-ctx.Done():\n            return ctx.Err()\n        default:\n        }\n        \n        c.setState(SyncConnecting)\n        \n        if err := c.Connect(ctx); err != nil {\n            c.setState(SyncError)\n            c.log(\"Connection failed: %v, retrying in %v\", err, backoff)\n            \n            select {\n            case \u003c-time.After(backoff):\n                backoff = min(backoff*2, maxBackoff)\n            case \u003c-ctx.Done():\n                return ctx.Err()\n            }\n            continue\n        }\n        \n        // Connected - reset backoff\n        backoff = time.Second\n        c.setState(SyncConnected)\n        \n        // Run sync loop\n        if err := c.syncLoop(ctx); err != nil {\n            if errors.Is(err, websocket.CloseNormalClosure) {\n                return nil\n            }\n            c.log(\"Sync error: %v\", err)\n            // Will reconnect on next iteration\n        }\n    }\n}\n```\n\n## Offline Queue\n\nQueue changes while disconnected:\n```go\ntype Client struct {\n    pendingChanges []Message\n    mu sync.Mutex\n}\n\nfunc (c *Client) queueChange(msg Message) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.pendingChanges = append(c.pendingChanges, msg)\n}\n\nfunc (c *Client) flushPending() error {\n    c.mu.Lock()\n    pending := c.pendingChanges\n    c.pendingChanges = nil\n    c.mu.Unlock()\n    \n    for _, msg := range pending {\n        if err := c.send(msg); err != nil {\n            // Re-queue and abort\n            c.mu.Lock()\n            c.pendingChanges = append(pending, c.pendingChanges...)\n            c.mu.Unlock()\n            return err\n        }\n    }\n    return nil\n}\n```\n\n## Status Display\n\nShow sync status in board UI:\n```\nBoard: http://localhost:3000\nCloud: https://tickboard.dev/pengelbrecht/ticks\nStatus: ● Connected [last sync: 2s ago]\n```\n\nOr:\n```\nStatus: ○ Reconnecting... (3 pending changes)\n```\n\n## Error Cases\n\n1. **Token expired:** Show message, prompt for new token\n2. **Project not found:** Clear error message\n3. **Rate limited:** Back off appropriately\n4. **Network offline:** Queue changes, sync on reconnect",
  "status": "closed",
  "priority": 2,
  "type": "task",
  "owner": "peter@engelbrecht.dk",
  "parent": "y1i",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-21T16:32:10.24316Z",
  "updated_at": "2026-01-21T18:50:07.181556Z",
  "closed_at": "2026-01-21T18:50:07.181556Z",
  "closed_reason": "Added SyncState type (Disconnected/Connecting/Connected/Error), state tracking with GetSyncState()/setSyncState()/OnStateChange callback. Added offline queue: queueMessage()/flushPendingMessages()/PendingCount(). SyncTick/SyncDelete now queue messages when disconnected instead of failing. Run() flushes pending on reconnect. Reduced max backoff to 30s."
}