{
  "acceptance_criteria": "- [ ] IsAwaitingHuman() returns true when Awaiting is set\n- [ ] IsAwaitingHuman() returns true when Manual is true (backwards compat)\n- [ ] GetAwaitingType() returns Awaiting value if set\n- [ ] GetAwaitingType() returns \"work\" if Manual is true and Awaiting is null\n- [ ] HasRequiredGate() returns true when Requires is set\n- [ ] IsTerminalAwaiting() correctly identifies terminal vs non-terminal states",
  "closed_at": "2026-01-14T16:32:47.238235Z",
  "closed_reason": "Added 4 workflow helper methods to Tick struct: IsAwaitingHuman() checks Awaiting or Manual flag, GetAwaitingType() returns awaiting type with backwards compat for Manual, HasRequiredGate() checks Requires field, IsTerminalAwaiting() identifies terminal states (approval/review/content/work). Tests added for all methods.",
  "created_at": "2026-01-14T16:15:53.822895Z",
  "created_by": "peter@engelbrecht.dk",
  "description": "Add helper methods to Tick struct for workflow state inspection:\n\n// IsAwaitingHuman returns true if tick is waiting for human action\nfunc (t *Tick) IsAwaitingHuman() bool\n\n// GetAwaitingType returns the awaiting type, handling backwards compat with Manual\nfunc (t *Tick) GetAwaitingType() string\n\n// HasRequiredGate returns true if tick has a pre-declared approval gate\nfunc (t *Tick) HasRequiredGate() bool\n\n// IsTerminalAwaiting returns true if approved verdict should close the tick\nfunc (t *Tick) IsTerminalAwaiting() bool\n\nTerminal awaiting types (approved = close): approval, review, content, work\nNon-terminal awaiting types (approved = back to agent): input, escalation, checkpoint",
  "id": "bet",
  "owner": "peter@engelbrecht.dk",
  "parent": "aee",
  "priority": 2,
  "run": {
    "session_id": "20f9c2a7-8775-4b6d-b08f-284f3140345f",
    "model": "claude-opus-4-5-20251101",
    "started_at": "2026-01-14T17:31:34.737932+01:00",
    "ended_at": "2026-01-14T17:33:09.285517+01:00",
    "output": "I'll review the epic notes and then implement the helper methods for workflow state inspection.\n\nLet me first examine the current state of the tick.go file to understand the existing structure:\n\nNow let me check the existing tests to understand the test pattern:\n\nNow I have a good understanding of the code structure. Let me implement the helper methods. Based on the task requirements:\n\n1. `IsAwaitingHuman()` - returns true if tick is waiting for human action (has Awaiting set or Manual flag)\n2. `GetAwaitingType()` - returns awaiting type, handling backwards compat with Manual\n3. `HasRequiredGate()` - returns true if tick has pre-declared approval gate (Requires is set)\n4. `IsTerminalAwaiting()` - returns true if approved verdict should close the tick\n\nTerminal awaiting types: approval, review, content, work\nNon-terminal awaiting types: input, escalation, checkpoint\n\nNow let me add tests for these helper methods:\n\nNow let me run the tests to verify everything works:\n\nAll tests pass. Let me also run the full test suite to ensure there are no regressions:\n\nAll tests pass. Now let me close the task:\n\nNow let me add a note for the next iteration:\n\nCompleted task [bet]. Summary of changes:\n\n**Added 4 helper methods to `internal/tick/tick.go` (lines 178-212):**\n\n1. **`IsAwaitingHuman()`** - Returns true if tick is waiting for human action (checks `Awaiting != nil` OR legacy `Manual` flag)\n\n2. **`GetAwaitingType()`** - Returns the awaiting type as a string:\n   - Returns `*Awaiting` value if Awaiting is set\n   - Returns `\"work\"` if Manual flag is set (backwards compatibility)\n   - Returns empty string if neither is set\n\n3. **`HasRequiredGate()`** - Returns true if tick has a pre-declared approval gate (`Requires != nil`)\n\n4. **`IsTerminalAwaiting()`** - Returns true if an approved verdict should close the tick:\n   - Terminal types: approval, review, content, work\n   - Non-terminal types: input, escalation, checkpoint\n\n**Tests added to `internal/tick/tick_test.go`** covering all scenarios including backwards compatibility with the Manual flag.",
    "tools": [
      {
        "name": "Read",
        "duration_ms": 492
      },
      {
        "name": "Read",
        "duration_ms": 364
      },
      {
        "name": "Edit",
        "duration_ms": 4128
      },
      {
        "name": "Edit",
        "duration_ms": 23020
      },
      {
        "name": "Bash",
        "duration_ms": 706
      },
      {
        "name": "Bash",
        "duration_ms": 628
      },
      {
        "name": "Bash",
        "duration_ms": 536
      },
      {
        "name": "Bash",
        "duration_ms": 2907
      },
      {
        "name": "Bash",
        "duration_ms": 3046
      },
      {
        "name": "Bash",
        "duration_ms": 3153
      }
    ],
    "metrics": {
      "input_tokens": 2,
      "output_tokens": 5066,
      "cache_read_tokens": 557109,
      "cache_creation_tokens": 23976,
      "cost_usd": 0.5727444999999998,
      "duration_ms": 94101
    },
    "success": true,
    "num_turns": 11
  },
  "status": "closed",
  "title": "Add helper methods for workflow state",
  "type": "task",
  "updated_at": "2026-01-14T16:32:47.238235Z"
}