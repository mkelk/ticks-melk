{
  "id": "z5s",
  "title": "Update cloud client to use DO WebSocket",
  "description": "Replace relay-based cloud client with DO sync client.\n\n## Changes to internal/tickboard/cloud/client.go\n\n### New Connection Target\n```go\nconst (\n    // Old: DefaultCloudURL = \"wss://tickboard.dev/agent\"\n    DefaultCloudURL = \"wss://tickboard.dev/api/projects\"\n)\n```\n\n### Updated Connect Method\n```go\nfunc (c *Client) Connect(ctx context.Context) error {\n    // Build DO URL with project name\n    url := fmt.Sprintf(\"%s/%s/sync?type=local\", c.cloudURL, c.boardName)\n    \n    conn, _, err := websocket.DefaultDialer.DialContext(ctx, url, nil)\n    if err != nil {\n        return err\n    }\n    \n    c.conn = conn\n    return nil\n}\n```\n\n### New Sync Methods\n```go\n// SyncTick sends a tick update to DO\nfunc (c *Client) SyncTick(t tick.Tick) error {\n    return c.sendMessage(Message{\n        Type: \"tick_update\",\n        Data: mustMarshal(t),\n    })\n}\n\n// SyncFullState sends all ticks to DO\nfunc (c *Client) SyncFullState(ticks []tick.Tick) error {\n    tickMap := make(map[string]tick.Tick)\n    for _, t := range ticks {\n        tickMap[t.ID] = t\n    }\n    return c.sendMessage(Message{\n        Type: \"sync_full\",\n        Data: mustMarshal(tickMap),\n    })\n}\n\n// SyncDelete notifies DO of tick deletion\nfunc (c *Client) SyncDelete(id string) error {\n    return c.sendMessage(Message{\n        Type: \"tick_delete\",\n        Data: mustMarshal(map[string]string{\"id\": id}),\n    })\n}\n```\n\n### Handle Incoming Updates\n```go\nfunc (c *Client) handleMessages(ctx context.Context) error {\n    for {\n        var msg Message\n        if err := c.conn.ReadJSON(\u0026msg); err != nil {\n            return err\n        }\n        \n        switch msg.Type {\n        case \"state_full\":\n            var ticks map[string]tick.Tick\n            json.Unmarshal(msg.Data, \u0026ticks)\n            c.applyRemoteState(ticks)\n            \n        case \"tick_updated\", \"tick_created\":\n            var t tick.Tick\n            json.Unmarshal(msg.Data, \u0026t)\n            c.applyRemoteTick(t)\n            \n        case \"tick_deleted\":\n            var data struct{ ID string }\n            json.Unmarshal(msg.Data, \u0026data)\n            c.applyRemoteDelete(data.ID)\n        }\n    }\n}\n\nfunc (c *Client) applyRemoteTick(t tick.Tick) {\n    // Write to local .tick/issues/\n    store := tick.NewStore(c.tickDir)\n    local, err := store.Read(t.ID)\n    \n    // Only apply if remote is newer\n    if err != nil || t.UpdatedAt.After(local.UpdatedAt) {\n        store.Write(t)\n    }\n}\n```\n\n### File Watcher Integration\n```go\nfunc (c *Client) WatchAndSync(ctx context.Context, tickDir string) error {\n    watcher, _ := fsnotify.NewWatcher()\n    watcher.Add(filepath.Join(tickDir, \"issues\"))\n    \n    for {\n        select {\n        case event := \u003c-watcher.Events:\n            if event.Op\u0026(fsnotify.Write|fsnotify.Create) != 0 {\n                t := c.loadTick(event.Name)\n                c.SyncTick(t)\n            }\n            if event.Op\u0026fsnotify.Remove != 0 {\n                id := extractID(event.Name)\n                c.SyncDelete(id)\n            }\n        case \u003c-ctx.Done():\n            return nil\n        }\n    }\n}\n```\n\n## Remove Old Relay Code\n\nDelete:\n- handleRequest() - no longer proxying HTTP\n- RegisterMessage - no longer registering for relay\n- RequestMessage/ResponseMessage - relay protocol",
  "status": "closed",
  "priority": 1,
  "type": "task",
  "owner": "peter@engelbrecht.dk",
  "parent": "y1i",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-21T16:30:50.162865Z",
  "updated_at": "2026-01-21T17:19:30.894209Z",
  "closed_at": "2026-01-21T17:19:30.894209Z",
  "closed_reason": "Implemented sync mode for cloud client. Added: ModeSync constant, SyncFullState/SyncTick/SyncDelete methods, file watcher for .tick/issues/, remote tick application with last-write-wins, echo prevention for local writes triggered by remote changes."
}