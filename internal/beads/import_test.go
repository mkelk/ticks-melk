package beads

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/mkelk/ticks-melk/internal/tick"
)

func TestImportE2E(t *testing.T) {
	// Parse the test fixture generated by real bd binary
	issues, err := ParseFile("testdata/issues.jsonl")
	if err != nil {
		t.Fatalf("failed to parse fixture: %v", err)
	}

	// Should have 8 issues total (7 open + 1 closed)
	if len(issues) != 8 {
		t.Errorf("expected 8 issues, got %d", len(issues))
	}

	// Create temp store
	tmpDir := t.TempDir()
	issuesDir := filepath.Join(tmpDir, "issues")
	if err := os.MkdirAll(issuesDir, 0755); err != nil {
		t.Fatalf("failed to create issues dir: %v", err)
	}
	store := tick.NewStore(tmpDir)

	// Import
	result, err := Import(issues, store, "testowner")
	if err != nil {
		t.Fatalf("import failed: %v", err)
	}

	// Should import 7, skip 1 (closed)
	if result.Imported != 7 {
		t.Errorf("expected 7 imported, got %d", result.Imported)
	}
	if result.Skipped != 1 {
		t.Errorf("expected 1 skipped, got %d", result.Skipped)
	}

	// Verify all imported ticks
	for beadsID, tickID := range result.IDMap {
		tk, err := store.Read(tickID)
		if err != nil {
			t.Errorf("failed to read imported tick %s (was %s): %v", tickID, beadsID, err)
			continue
		}

		// Find original issue
		var original *Issue
		for i := range issues {
			if issues[i].ID == beadsID {
				original = &issues[i]
				break
			}
		}
		if original == nil {
			t.Errorf("couldn't find original issue for %s", beadsID)
			continue
		}

		// Verify field mapping
		if tk.Title != original.Title {
			t.Errorf("title mismatch: got %q, want %q", tk.Title, original.Title)
		}
		if tk.Description != original.Description {
			t.Errorf("description mismatch for %s", beadsID)
		}
		if tk.Notes != original.Notes {
			t.Errorf("notes mismatch for %s", beadsID)
		}
		if tk.Priority != original.Priority {
			t.Errorf("priority mismatch for %s: got %d, want %d", beadsID, tk.Priority, original.Priority)
		}
		if tk.AcceptanceCriteria != original.AcceptanceCriteria {
			t.Errorf("acceptance_criteria mismatch for %s", beadsID)
		}
		if tk.ExternalRef != original.ExternalRef {
			t.Errorf("external_ref mismatch for %s", beadsID)
		}

		// Labels should match
		if len(tk.Labels) != len(original.Labels) {
			t.Errorf("labels length mismatch for %s: got %d, want %d", beadsID, len(tk.Labels), len(original.Labels))
		}

		// Owner should be the provided owner, not assignee
		if tk.Owner != "testowner" {
			t.Errorf("owner should be testowner, got %s", tk.Owner)
		}

		// CreatedBy should be the provided owner
		if tk.CreatedBy != "testowner" {
			t.Errorf("created_by should be testowner, got %s", tk.CreatedBy)
		}

		// Timestamps should be preserved
		if !tk.CreatedAt.Equal(original.CreatedAt) {
			t.Errorf("created_at mismatch for %s: got %v, want %v", beadsID, tk.CreatedAt, original.CreatedAt)
		}
		if !tk.UpdatedAt.Equal(original.UpdatedAt) {
			t.Errorf("updated_at mismatch for %s: got %v, want %v", beadsID, tk.UpdatedAt, original.UpdatedAt)
		}

		// Type should be mapped correctly
		switch original.IssueType {
		case "bug", "feature", "task", "epic", "chore":
			if tk.Type != original.IssueType {
				t.Errorf("type mismatch for %s: got %s, want %s", beadsID, tk.Type, original.IssueType)
			}
		default:
			if tk.Type != "task" {
				t.Errorf("unknown type should map to task, got %s", tk.Type)
			}
		}
	}

	// Verify parent relationships are remapped
	// Find an issue that has a parent-child dependency
	for beadsID, tickID := range result.IDMap {
		tk, _ := store.Read(tickID)
		var original *Issue
		for i := range issues {
			if issues[i].ID == beadsID {
				original = &issues[i]
				break
			}
		}
		if original == nil {
			continue
		}

		// Check parent mapping
		for _, dep := range original.Dependencies {
			if dep.Type == "parent-child" {
				expectedParent, ok := result.IDMap[dep.DependsOnID]
				if ok && tk.Parent != expectedParent {
					t.Errorf("parent not remapped correctly for %s: got %s, want %s", beadsID, tk.Parent, expectedParent)
				}
			}
			if dep.Type == "blocks" {
				expectedBlocker, ok := result.IDMap[dep.DependsOnID]
				if ok {
					found := false
					for _, b := range tk.BlockedBy {
						if b == expectedBlocker {
							found = true
							break
						}
					}
					if !found {
						t.Errorf("blocker not remapped correctly for %s: expected %s in %v", beadsID, expectedBlocker, tk.BlockedBy)
					}
				}
			}
		}
	}
}

func TestFilterImportable(t *testing.T) {
	now := time.Now()
	issues := []Issue{
		{ID: "1", Status: "open"},
		{ID: "2", Status: "in_progress"},
		{ID: "3", Status: "closed"},
		{ID: "4", Status: "tombstone"},
		{ID: "5", Status: "open", DeletedAt: &now},
		{ID: "6", Status: "deferred"},
	}

	filtered := FilterImportable(issues)

	// Should include: 1, 2, 6 (open, in_progress, deferred)
	// Should exclude: 3 (closed), 4 (tombstone), 5 (deleted)
	if len(filtered) != 3 {
		t.Errorf("expected 3 importable, got %d", len(filtered))
	}

	ids := make(map[string]bool)
	for _, issue := range filtered {
		ids[issue.ID] = true
	}

	if !ids["1"] || !ids["2"] || !ids["6"] {
		t.Errorf("unexpected filter result: %v", filtered)
	}
	if ids["3"] || ids["4"] || ids["5"] {
		t.Errorf("closed/tombstone/deleted issues should be filtered: %v", filtered)
	}
}
